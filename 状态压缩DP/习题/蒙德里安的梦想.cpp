#include <iostream>
#include <cstring>

using namespace std;

// https://www.acwing.com/problem/content/293/

// N表示列数，M表示列上的所有状态（二进制位为1表示上一列向这一列捅了出来）
const int N = 12, M = 1 << N;

long long f[N][M]; // f[i][j]表示排到i号列，j的二进制位为1的位置是i-1列捅过来的
bool st[M]; // 表示当前处理某一列时，每个状态j能否满足没有奇数连续空行

int main() {
    int n, m; // n行m列
    
    while (cin >> n >> m, n || m) {
        // 每一组新数据要清空dp数组
        memset(f, 0, sizeof f);
        // 预处理所有的状态j是否存在连续的奇数个空行，如果存在就是false，否则是true
        for (int j = 0; j < 1 << n; j ++ ) { // 枚举所有的状态j
            int cnt = 0; // 计数，连续空行的个数
            st[j] = true; // true表示没有奇数连续空行
            // 从上到下枚举所有的行
            for (int i = 0; i < n; i ++ ) {
                // 如果当前状态j表明这一行是被横着排列的（非空行）
                if (j >> i & 1) {
                    // 说明这是一个“连续空行”的结束位置，判断一下“连续空行”有多少个
                    // 如果是奇数个，那就说明这个状态不行
                    if (cnt & 1)
                        st[j] = false;
                    // 因为这个位置是连续空行的结束位置，所以把连续空行的计数清零
                    cnt = 0;
                }
                // 否则，即这一行是空行
                else
                    cnt ++; // 只要增长这个空行计数
            }
            // 枚举完成之后，末尾的连续空行还没有判断，判断一下，是奇数就置false
            if (cnt & 1)
                st[j] = false;
        }
        // dp过程，在第0列的时候，上一列一定不能有格子捅进来，所以状态j也一定是0，方案数就是1
        f[0][0] = 1;
        // 要计算dp数组f，先遍历所有的列
        // 因为答案是f[m][0]，即越过最后一列后，没有格子捅进来
        // 所以要遍历到m，而不是m-1
        for (int i = 1; i <= m; i ++ ) {
            // 遍历所有的状态j
            for (int j = 0; j < 1 << n; j ++ ) {
                // 遍历上一列（i-1列）的所有状态k
                for (int k = 0; k < 1 << n; k ++ ) {
                    // 如果这两列横排的格子没有冲突，并且剩下没横排的空行没有连续奇数导致没法竖排
                    if ((j & k) == 0 && st[j | k]) {
                        // i列的状态j就包括i-1列的状态k这个情况，加进来
                        f[i][j] += f[i - 1][k];
                    }
                }
            }
        }
        // 结果是越过最后一行时，没有捅过来的
        cout << f[m][0] << endl;
    }
    
    return 0;
}
