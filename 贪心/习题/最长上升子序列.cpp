#include <iostream>

using namespace std;


// https://www.acwing.com/problem/content/898/

// 在朴素的解法（见线性DP）里有一些多余的计算
// 例如 3 1 2 1 8 5 6
// f[1]即一个数3，是1
// f[2]即一个数1，也是1
// 这个时候后面所有能接到3后面的一定都能接到1的后面
// 也就是对于长度一样的上升子序列，结尾小的一定比结尾大的要好
// 所以可以在遍历的时候维护一下每个长度的上升子序列结尾最小的一个，结尾是多少
// 显然长度越大的上升子序列，结尾的最小值一定是严格递增的
// 所以每次求以a[i]结尾的最长的上升子序列长度，就是要从维护的数组中找一个最大的小于a[i]的数
// 比如a[i]接到q[4]（长度是4的上升子序列，结尾最小）后面，那么就得到了一个长度是5的上升子序列
// 因为a[i]接到q[4]后面，所以q[5]一定是>=a[i]的，所以可以用a[i]更新q[5] 
// 在有序数组q中找到一个小于a[i]的数可以用二分 
// 时间复杂度：一共n个数，每个数O(logn)时间找接入点，所以总共是O(nlogn) 

const int N = 1e5 + 10;

int a[N], q[N]; // q[i]存长度是i的上升子序列的最小结尾数字 

int main() {
	int n;
	scanf("%d", &n);
	
	for (int i = 0; i < n; i ++)
		scanf("%d", a + i);
	
	// q数组长度，也是答案（最大子序列的长度） 
	int qlen = 0; 
	
	// 对每个数二分找q数组里小于它的数
	// 为了保证一定能找到，q[0]做哨兵
	q[0] = -1e9 - 10;
	for (int i = 0; i < n; i ++) {
		int l = 0, r = qlen;
		while (l < r) {
			int mid = l + r + 1 >> 1;
			if (q[mid] < a[i])
				l = mid;
			else
				r = mid - 1;
		}
		// 找到的q[r]就是小于a[i]的最小数
		// 更新长度为r + 1的子序列的最小值 
		q[r + 1] = a[i]; // q[r + 1]一定>=a[i] 
		// 更新q数组长度
		qlen = max(qlen, r + 1); 
	}
	
	printf("%d\n", qlen);
	
	return 0;
}
