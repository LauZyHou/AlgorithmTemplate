#include <iostream>
#include <algorithm>

using namespace std;

/*
https://www.acwing.com/problem/content/description/840/

以下描述的都是(小顶)堆

支持的操作： 
1. 插入一个数
2. 求其中的最小值
3. 删除最小值
4. 删除任意一个元素
5. 修改任意一个元素
其中4和5在STL中的堆是不支持的，所以有时候要手写堆 

性质： 
是一棵完全二叉树，每个结点都<=左右子孩子结点
所以每棵子树也是一个小顶堆 

存储：
用一维数组来存这一棵树 
1号是根结点，结点x的左右儿子是2x和2x+1 

操作：
down(u)：
	在小顶堆里如果把某个点的值变大了，那么就要往下交换调整 
	每次比较自己和左右两个孩子结点，取三者的最小值和自己交换 
up(u)：
	在小顶堆里如果把某个点的值变小了，那么就要往上交换调整 
	每次比较自己和父结点的大小，如果自己小就往上交换 

用上面两个操作拼出所需要支持的操作：
1. 插入一个数
	heap[++ size] = x; // 插到末尾（树的最后一排最右边） 
	up(size); // 从这个新元素位置，向上调整成堆
2. 求其中的最小值
	return heap[1]; // 堆顶的元素就是最小值
3. 删除最小值
	heap[1] = heap[size]; // 用最后一个元素盖掉堆顶最小值元素
	size --; // 删掉最后一个元素
	down(1); // 从堆顶元素位置，向下调整成堆 
4. 删除任意一个元素 
	heap[k] = heap[size]; // 用最后一个元素盖掉要删除的第k个元素
	size --; // 删掉最后一个元素
	down(k), up(k); // 这个位置有可能变小也有可能变大，这里两个实际只有一个起作用
5. 修改任意一个元素
	heap[k] = x; // 将要改的元素改掉
	down(k), up(k); // 这个位置有可能变小也有可能变大，这里两个实际只有一个起作用
*/

const int N = 1e5 + 10;

int n, m;

// 数组存堆
int h[N];

// 当前使用的大小
int sz;

// 向下调整成堆
void down(int u) {
	// t存u号结点和其左右孩子之间最小的那个的下标 
	int t = u;
	// 注意要检查左右孩子存在不存在，即在sz大小内 
	if (u * 2 <= sz && h[u * 2] < h[t])
		t = u * 2;
	if (u * 2 + 1 <= sz && h[u * 2 + 1] < h[t])
		t = u * 2 + 1;
	if (t != u) {
		swap(h[t], h[u]);
		down(t);
	}
}


// 向上调整成堆
void up(int u) {
	// 有父节点 并且 父节点更大 
	while (u / 2 && h[u / 2] > h[u]) {
		swap(h[u /2], h[u]); // 和父节点交换 
		u /= 2; // 指针向上走 
	}
} 


int main() {
	// n个数，要取前m小的数从小到大输出 
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i ++) {
		scanf("%d", &h[i]);
	}
	sz = n;
	
	// O(n)时间调整成堆
	for (int i = n / 2; i; i --) {
		down(i);
	}
	
	while (m --) {
		printf("%d ", h[1]);
		h[1] = h[sz];
		sz --;
		down(1);
	}
	
	return 0;
}
