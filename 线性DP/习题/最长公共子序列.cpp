#include <iostream>

using namespace std;

// https://www.acwing.com/problem/content/899/

// 状态表示：dp[i,j]
// 集合：所有由第一个序列的前i个字母，和第二个序列的前j个字母构成的公共子序列
// 属性：集合中所有子序列最长的值
// 状态计算（集合划分）：以a[i]和b[j]是否包含在公共子序列当中作为划分依据，有四种情况
// 为了描述方便，00表示a[i]和b[j]都不选，11表示都选
// 所以f[i,j]就是00/01/10/11四个集合的最大值
// 00：f[i-1,j-1]
// 11：f[i-1,j-1]+1
// 01：f[i-1,j]按照定义是严格包含01这种情况的，但是这个集合其余的部分也在00当中
// 10：f[i,j-1]按照定义是严格包含10这种情况的，但是这个集合其余的部分也在00当中
// 01和10两个集合没法拿出来，但是因为要求的是四个集合里的Max，所以这里可以用f[i-1,j]和f[i,j-1]来代替
// Max运算集合有重叠没关系，只要并集就是和要求的集合一样就行了
// 例如ABC是集合，max(A,B)与max(B,C)再求一个max，就和max(A,B,C)的max是一样的 
// 在实际写代码时00这个集合不用写，因为它被包含在了01和10集合当中 

const int N = 1010;

char a[N], b[N];

int f[N][N];

int main() {
	int n, m;
	scanf("%d%d", &n, &m);
	scanf("%s%s", a + 1, b + 1);
	
	for (int i = 1; i <= n; i ++) {
		for (int j = 1; j <= m; j ++) {
			f[i][j] = max(f[i - 1][j], f[i][j - 1]);
			if (a[i] == b[j])
				f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1);
		}
	}
	
	printf("%d\n", f[n][m]);
	
	return 0;
}
